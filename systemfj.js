// Generated by CoffeeScript 2.0.1
(function() {
  // base class shouldnt be used directly
  var Constructor, Function, T, Type, TypeVar, Var, Variable, length, tBOTTOM, tCustom, tEither, tEmpty, tFloat, tInt, tList, tMaybe, tPair, tPeano, tString, tTOP, tUnit;

  Variable = class Variable {
    constructor(name1, boundTo) {
      this.name = name1;
      this.boundTo = boundTo; // boundTo is used in lambda and type functions to index to which variable current one is bound
    }

    bind(val) {
      throw "Variable::bind() shouldn't be called directly!";
    }

    show() {
      return console.dir(this);
    }

  };

  // used for type variables
  TypeVar = class TypeVar extends Variable {
    constructor(name, boundTo) {
      super(name, boundTo);
    }

    kind() {} // should return Kind of a type variable's current value

    bind(val) {
      throw "TypeVar::bind() not implemented yet";
    }

  };

  // used for regular variables
  Var = class Var extends Variable {
    constructor(name, boundTo, type) {
      super(name, boundTo);
      this.type = type;
    }

    type() {
      return this.type; // should return Type that our variable indexes - can be either TypeVar OR specific type
    }

    bind(val) {
      throw "Var::bind() not implemented yet";
    }

  };

  // class generating Product Type values (records)
  // Should NOT be available to constuct publicly, only from inside of Type
  Constructor = class Constructor {
    constructor(name1, vars) {
      this.name = name1;
      this.vars = [];
      if (vars != null) {
        this.vars = vars;
      }
    }

    // internal method assigning a value to n-th variable, doing typechecking etc along the way
    _instantiate(n, val) {}

    // same as above but instantiates type for n-th variable, needed to e.g. create Just Int from Just a
    _instantiateType(n, type) {}

    // creates new value of the current type, typechecks etc
    new(vals) {}

  };

  Type = class Type {
    // create a new type with name and type variables (no regular vars as no dependent types yet)
    // e.g. Maybe = new Type "Maybe a"
    constructor(type, ...constructors) {
      var cons, i, j, len, xs;
      xs = type.split(' ');
      this.name = xs[0];
      // creating TypeVars for each var name in the constructor
      this.vars = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 1, ref = xs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
          results.push(new TypeVar(xs[i], -1));
        }
        return results;
      })();
      // adding constructors
      for (j = 0, len = constructors.length; j < len; j++) {
        cons = constructors[j];
        this.add(cons);
      }
      Type[this.name] = this; // adding this type to the list of all types
    }

    
    // adding a new constructor to this type in the same format as Type constructor,
    // e.g. "Just a" or "MyPair Int Float"
    add(cons) {
      var i, j, name, ref, t, v, vars, xs;
      xs = cons.split(' ');
      name = xs[0];
      vars = [];
      for (i = j = 1, ref = xs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        // finding an index of the variable with the name given
        v = this.vars.findIndex((el) => {
          return el.name === xs[i];
        });
        if (v !== -1) { // found a variable, need to bind
          // tricky: creating a Var of type TypeVar that is bound to an index found
          vars.push(new Var((i - 1).toString(), -1, new TypeVar(xs[i], v)));
        } else {
          if (xs[i] === this.name) { // recursive type
            vars.push(new Var((i - 1).toString(), -1, this)); // since this is recursive type, just giving our var a reference to this
// final option: need to look in existing types
          } else {
            t = Type[xs[i]];
            // adding concrete type instead of a variable. No checking for it being a concrete type etc, very rudimentary
            if (t != null) {
              vars.push(new Var((i - 1).toString(), -1, t)); // error, nothing is found. TODO: handle error more gracefully
            } else {
              throw "Type " + xs[i] + " not found!";
            }
          }
        }
      }
      cons = new Constructor(name, vars);
      return this[cons.name] = cons;
    }

  };

  // some built in types
  tTOP = new Type("_TOP_"); // top type of all types - for the future subtyping?

  tBOTTOM = new Type("_BOTTOM_"); // _|_ in Haskell

  tEmpty = new Type("_EMPTY_"); // () in Haskell

  tUnit = new Type("_UNIT_", "Unit"); // type with a single element

  
  // primitive types (substituted into js types directly)
  tInt = new Type("Int", "I#");

  tFloat = new Type("Float", "F#");

  tString = new Type("String", "S#");

  // some standard types
  tPair = new Type("Pair a b", "Pair a b");

  tEither = new Type("Either a b", "Left a", "Right b");

  tMaybe = new Type("Maybe a", "Just a", "Nothing");

  tList = new Type("List a", "Cell a List", "Nil");

  tPeano = new Type("Nat", "Z", "S Nat");

  T = Type; // alias for global types, so that we can write things like T.Int

  
  // our functional function with pattern matching and type checking and polymorphism
  Function = class Function {
    constructor(name1) {
      this.name = name1;
      this.functions = {};
    }

    match(consTag, func) {
      return this.functions[consTag] = func;
    }

    // function application - think through
    ap(vals) {}

  };

  // Some tests #################################################

  //Maybe.add "Nothing"
  //Maybe.add "Just a"
  //tMaybe.add "Crazy Int"
  //tMaybe.add "MoreCrazy Afasf"
  tCustom = new Type("Custom", "Cons Int");

  length = new Function("length");

  length.match("Nil", function() {
    return 0;
  });

  length.match("Cell", function(x) {
    return 1 + length.ap(tail(x));
  });

  //console.dir length
  //console.dir Maybe, {depth: 4, colors: true}
  //console.dir List, {depth: 4, colors: true}
  console.dir(Type, {
    depth: 5,
    colors: true
  });

}).call(this);
