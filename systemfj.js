// Generated by CoffeeScript 2.0.1
(function() {
  // base class shouldnt be used directly
  var Constructor, Func, T, Type, TypeVar, Value, Var, Variable, length, t1, tBOTTOM, tCustom, tEither, tEmpty, tFloat, tInt, tList, tMaybe, tPair, tPeano, tString, tTOP, tUnit, two, z,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Variable = class Variable {
    constructor(name1, boundTo) {
      this.name = name1;
      this.boundTo = boundTo; // boundTo is used in lambda and type functions to index to which variable current one is bound
    }

    bind(val) {
      throw "Variable::bind() shouldn't be called directly!";
    }

    show() {
      return console.dir(this);
    }

  };

  TypeVar = class TypeVar extends Variable {
    constructor(name, boundTo) {
      super(name, boundTo);
      this.show = this.show.bind(this);
    }

    kind() {} // should return Kind of a type variable's current value

    bind(val) {
      throw "TypeVar::bind() not implemented yet";
    }

    show() {
      // used for type variables
      boundMethodCheck(this, TypeVar);
      return this.name + " :: " + "Type";
    }

  };

  Var = class Var extends Variable {
    constructor(name, boundTo, type) {
      super(name, boundTo);
      this.show = this.show.bind(this);
      this.type = type;
    }

    type() {
      return this.type; // should return Type that our variable indexes - can be either TypeVar OR specific type
    }

    bind(val) {
      throw "Var::bind() not implemented yet";
    }

    show() {
      // used for regular variables
      boundMethodCheck(this, Var);
      return this.name + " :: " + this.type.name;
    }

  };

  // class for holding values - basically, a record. Do we even need a class here?
  Value = class Value {
    // pass in constructorTag and reference to type, add value fields as needed
    // for now passing reference to Type, ideally need to do all type checking via
    // constructorTags only for efficiency
    constructor(_constructorTag_, _type_) {
      // pretty printing values
      this.show = this.show.bind(this);
      this._constructorTag_ = _constructorTag_;
      this._type_ = _type_;
    }

    show(top_level = true) {
      var j, keys, len, ret, v;
      keys = (function() {
        var j, len, ref, results;
        ref = Object.keys(this);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          v = ref[j];
          if (v !== "show" && v !== "_constructorTag_" && v !== "_type_") {
            results.push(v);
          }
        }
        return results;
      }).call(this);
      ret = (keys.length > 0) && (!top_level) ? "(" + this._constructorTag_ : this._constructorTag_; //+ " :: " + @_type_.name
      //console.log "Properties: --------------------------"
      //console.dir keys
      for (j = 0, len = keys.length; j < len; j++) {
        v = keys[j];
        if (this[v] instanceof Value) {
          ret = ret + " " + (this[v].show(false));
        } else {
          ret = ret + " " + this[v].toString();
        }
      }
      ret = (keys.length > 0) && (!top_level) ? ret + ")" : ret;
      if (top_level) {
        ret = ret + " :: " + this._type_.name;
      }
      return ret;
    }

  };

  // class generating Product Type values (records)
  // Should NOT be available to constuct publicly, only from inside of Type
  Constructor = class Constructor {
    constructor(name1, type1, vars) {
      // creates new value of the current type, typechecks etc
      // this is the main function to construct values
      // now very inefficient
      // bound since we are doing some fancy assignments for better syntax
      this.new = this.new.bind(this);
      this.name = name1;
      this.type = type1;
      this.vars = [];
      if (vars != null) {
        this.vars = vars;
      }
    }

    // internal method assigning a value to n-th variable, doing typechecking etc along the way
    _instantiate(n, val) {}

    // same as above but instantiates type for n-th variable, needed to e.g. create Just Int from Just a
    _instantiateType(n, type) {}

    new(...vals) {
      var i, j, ref, v, val;
      //console.log "Calling new!"
      //console.dir vals
      if (this.vars.length === 0) {
        return new Value(this.name, this.type); // empty constructor is easy
      } else {
        //console.log "Compound constructor"
        val = new Value(this.name, this.type);
        for (i = j = 0, ref = this.vars.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          //console.log "Processing " + @vars[i].show()
          //console.dir vals[i]
          v = vals[i];
          if (v != null) {
            if (this.vars[i].type.equals(Type.checkType(v))) { // are the types ok?
              val[this.vars[i].name] = v;
            } else {
              throw "Type mismatch in assignment!";
            }
          }
        }
        return val;
      }
    }

  };

  // Class that contains all types in the system and at the same time serves as a SumType
  // of Constructors (which are Product types)
  Type = class Type {
    // create a new type with name and type variables (no regular vars as no dependent types yet)
    // e.g. Maybe = new Type "Maybe a"
    constructor(type, ...constructors) {
      var cons, i, j, len, xs;
      
      // comparing 2 types, for now very basic (simply name)
      this.equals = this.equals.bind(this);
      // adding a new constructor to this type in the same format as Type constructor,
      // e.g. "Just a" or "MyPair Int Float"
      this.add = this.add.bind(this);
      this.constructors = {};
      xs = type.split(' ');
      this.name = xs[0];
      // creating TypeVars for each var name in the constructor
      this.vars = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 1, ref = xs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
          results.push(new TypeVar(xs[i], -1));
        }
        return results;
      })();
      // adding constructors
      for (j = 0, len = constructors.length; j < len; j++) {
        cons = constructors[j];
        this.add(cons);
      }
      Type[this.name] = this; // adding this type to the list of all types
    }

    equals(type) {
      return this.name === type.name;
    }

    add(cons) {
      var i, j, name, ref, t, v, vars, xs;
      xs = cons.split(' ');
      name = xs[0];
      vars = [];
      for (i = j = 1, ref = xs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        // finding an index of the variable with the name given
        v = this.vars.findIndex((el) => {
          return el.name === xs[i];
        });
        if (v !== -1) { // found a variable, need to bind
          // tricky: creating a Var of type TypeVar that is bound to an index found
          vars.push(new Var((i - 1).toString(), -1, new TypeVar(xs[i], v)));
        } else {
          if (xs[i] === this.name) { // recursive type
            vars.push(new Var((i - 1).toString(), -1, this)); // since this is recursive type, just giving our var a reference to this
// final option: need to look in existing types
          } else {
            t = Type[xs[i]];
            // adding concrete type instead of a variable. No checking for it being a concrete type etc, very rudimentary
            if (t != null) {
              vars.push(new Var((i - 1).toString(), -1, t)); // error, nothing is found. TODO: handle error more gracefully
            } else {
              throw "Type " + xs[i] + " not found!";
            }
          }
        }
      }
      cons = new Constructor(name, this, vars);
      this.constructors[cons.name] = cons; // adding constructor to the list of constructors
      return this[cons.name] = cons.new; // adding "new" generating function as a constructor name - for cleaner syntax!
    }

    //@[cons.name].bind cons # binding this to newly created constructor

    // helper function that returns name of the type *even if v is not Value* but a primitive type
    static checkType(v) {
      if (v instanceof Value) {
        return v._type_;
      } else {
        switch (typeof v) {
          case "string":
            return Type.String;
          case "number":
            return Type.Float;
          default:
            throw "We got an unboxed value of type " + (typeof v) + " -- shouldn't happen!";
        }
      }
    }

  };

  // some built in types
  tTOP = new Type("_TOP_"); // top type of all types - for the future subtyping?

  tBOTTOM = new Type("_BOTTOM_"); // _|_ in Haskell

  tEmpty = new Type("_EMPTY_"); // () in Haskell

  tUnit = new Type("_UNIT_", "Unit"); // type with a single element

  
  // primitive types (substituted into js types directly)
  tInt = new Type("Int", "I#");

  tFloat = new Type("Float", "F#");

  tString = new Type("String", "S#");

  // some standard types
  tPair = new Type("Pair a b", "Pair a b");

  tEither = new Type("Either a b", "Left a", "Right b");

  tMaybe = new Type("Maybe a", "Just a", "Nothing");

  tList = new Type("List a", "Cell a List", "Nil");

  tPeano = new Type("Nat", "Z", "S Nat");

  T = Type; // alias for global types, so that we can write things like T.Int

  
  // our functional function with pattern matching and type checking and polymorphism
  Func = class Func {
    constructor(name1) {
      this.name = name1;
      this.functions = {};
    }

    match(consTag, func) {
      return this.functions[consTag] = func;
    }

    // function application - think through
    ap(vals) {}

  };

  // Some tests #################################################

  //Maybe.add "Nothing"
  //Maybe.add "Just a"
  //tMaybe.add "Crazy Int"
  //tMaybe.add "MoreCrazy Afasf"
  tCustom = new Type("Custom", "Cons Float String");

  length = new Func("length");

  length.match("Nil", function() {
    return 0;
  });

  length.match("Cell", function(x) {
    return 1 + length.ap(tail(x));
  });

  //console.dir length
  //console.dir Maybe, {depth: 4, colors: true}
  //console.dir List, {depth: 4, colors: true}
  console.dir(Type, {
    depth: 5,
    colors: true
  });

  z = T.Nat.Z();

  two = T.Nat.S(T.Nat.S(T.Nat.S(T.Nat.Z())));

  console.log(z.show());

  console.log(two.show());

  t1 = T.Custom.Cons(2, "Hello");

  console.log(t1.show());

}).call(this);
