// Generated by CoffeeScript 2.0.1
(function() {
  // base class shouldnt be used directly
  var BOTTOM, Cell, Constructor, EMPTY, Func, JFloat, JInt, JString, Just, Left, Nil, Nothing, Pair, Right, S, T, TOP, Type, TypeVar, UNIT, Unit, Value, Var, Variable, Z, f1, j, len, length, ref, t, t1, tCustom, toInt, two, y0, y1,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Variable = class Variable {
    constructor(name1, boundTo) {
      this.name = name1;
      this.boundTo = boundTo; // boundTo is used in lambda and type functions to index to which variable current one is bound
    }

    bind(val) {
      throw "Variable::bind() shouldn't be called directly!";
    }

    show() {
      return console.dir(this);
    }

  };

  TypeVar = class TypeVar extends Variable {
    constructor(name, boundTo) {
      super(name, boundTo);
      this.show = this.show.bind(this);
      this.shortShow = this.shortShow.bind(this);
    }

    kind() {} // should return Kind of a type variable's current value

    bind(val) {
      throw "TypeVar::bind() not implemented yet";
    }

    show() {
      // used for type variables
      boundMethodCheck(this, TypeVar);
      return this.name + " :: " + "Type";
    }

    shortShow() {
      boundMethodCheck(this, TypeVar);
      return this.name;
    }

  };

  Var = class Var extends Variable {
    constructor(name, boundTo, type) {
      super(name, boundTo);
      this.show = this.show.bind(this);
      this.type = type;
    }

    type() {
      return this.type; // should return Type that our variable indexes - can be either TypeVar OR specific type
    }

    bind(val) {
      throw "Var::bind() not implemented yet";
    }

    show() {
      // used for regular variables
      boundMethodCheck(this, Var);
      return this.name + " :: " + this.type.name;
    }

  };

  // class for holding values - basically, a record. Do we even need a class here?
  Value = class Value {
    // pass in constructorTag and reference to type, add value fields as needed
    // for now passing reference to Type, ideally need to do all type checking via
    // constructorTags only for efficiency
    constructor(_constructorTag_, _type_) {
      // pretty printing values
      this.show = this.show.bind(this);
      this._constructorTag_ = _constructorTag_;
      this._type_ = _type_;
    }

    show(top_level = true) {
      var j, keys, len, ret, v;
      keys = (function() {
        var j, len, ref, results;
        ref = Object.keys(this);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          v = ref[j];
          if (v !== "show" && v !== "_constructorTag_" && v !== "_type_") {
            results.push(v);
          }
        }
        return results;
      }).call(this);
      ret = (keys.length > 0) && (!top_level) ? "(" + this._constructorTag_ : this._constructorTag_; //+ " :: " + @_type_.name
      //console.log "Properties: --------------------------"
      //console.dir keys
      for (j = 0, len = keys.length; j < len; j++) {
        v = keys[j];
        if (this[v] instanceof Value) {
          ret = ret + " " + (this[v].show(false));
        } else {
          ret += (typeof this[v] === "string") ? " '" + this[v] + "'" : " " + this[v].toString();
        }
      }
      ret = (keys.length > 0) && (!top_level) ? ret + ")" : ret;
      if (top_level) {
        ret = ret + " :: " + this._type_.name;
      }
      return ret;
    }

  };

  // class generating Product Type values (records)
  // Should NOT be available to constuct publicly, only from inside of Type
  // now can only generate Tuples (unnamed records)
  Constructor = class Constructor {
    constructor(name1, type1, vars) {
      // creates new value of the current type, typechecks etc
      // this is the main function to construct values
      // now very inefficient
      // bound since we are doing some fancy assignments for better syntax
      this.new = this.new.bind(this);
      this.show = this.show.bind(this);
      this.name = name1;
      this.type = type1;
      this.vars = [];
      if (vars != null) {
        this.vars = vars;
      }
    }

    // internal method assigning a value to n-th variable, doing typechecking etc along the way
    _instantiate(n, val) {}

    // same as above but instantiates type for n-th variable, needed to e.g. create Just Int from Just a
    _instantiateType(n, type) {}

    new(...vals) {
      var i, j, ref, v, val;
      //console.log "Calling new!"
      //console.dir vals
      if (this.vars.length === 0) {
        return new Value(this.name, this.type); // empty constructor is easy
      } else {
        //console.log "Compound constructor"
        val = new Value(this.name, this.type);
        for (i = j = 0, ref = this.vars.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          //console.log "Processing " + @vars[i].show()
          //console.dir vals[i]
          v = vals[i];
          if (v != null) {
            if (this.vars[i].type.equals(Type.checkType(v))) { // are the types ok? doesnt work for polymorphic yet!!!
              val[this.vars[i].name] = v;
            } else {
              throw "Type mismatch in assignment!";
            }
          }
        }
        return val;
      }
    }

    show() {
      var j, len, ref, ret, v;
      ret = this.name;
      ref = this.vars;
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        ret = ret + " " + v.type.shortShow(true);
      }
      return ret;
    }

  };

  // Class that contains all types in the system and at the same time serves as a SumType
  // of Constructors (which are Product types)
  Type = class Type {
    // create a new type with name and type variables (no regular vars as no dependent types yet)
    // e.g. Maybe = new Type "Maybe a"
    constructor(type, ...constructors) {
      var cons, i, j, len, xs;
      
      // comparing 2 types, for now very basic (simply name)
      this.equals = this.equals.bind(this);
      // adding a new constructor to this type in the same format as Type constructor,
      // e.g. "Just a" or "MyPair Int Float"
      this.add = this.add.bind(this);
      this.shortShow = this.shortShow.bind(this);
      this.show = this.show.bind(this);
      this.constructors = {};
      xs = type.split(' ');
      this.name = xs[0];
      // creating TypeVars for each var name in the constructor
      this.vars = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 1, ref = xs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
          results.push(new TypeVar(xs[i], -1));
        }
        return results;
      })();
      // adding constructors
      for (j = 0, len = constructors.length; j < len; j++) {
        cons = constructors[j];
        this.add(cons);
      }
      Type[this.name] = this; // adding this type to the list of all types
    }

    equals(type) {
      return this.name === type.name;
    }

    add(cons) {
      var i, j, name, ref, t, v, vars, xs;
      xs = cons.split(' ');
      name = xs[0];
      vars = [];
      for (i = j = 1, ref = xs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        // finding an index of the variable with the name given
        v = this.vars.findIndex((el) => {
          return el.name === xs[i];
        });
        if (v !== -1) { // found a variable, need to bind
          // tricky: creating a Var of type TypeVar that is bound to an index found
          vars.push(new Var((i - 1).toString(), -1, new TypeVar(xs[i], v)));
        } else {
          if (xs[i] === this.name) { // recursive type
            vars.push(new Var((i - 1).toString(), -1, this)); // since this is recursive type, just giving our var a reference to this
// final option: need to look in existing types
          } else {
            t = Type[xs[i]];
            // adding concrete type instead of a variable. No checking for it being a concrete type etc, very rudimentary
            if (t != null) {
              vars.push(new Var((i - 1).toString(), -1, t)); // error, nothing is found. TODO: handle error more gracefully
            } else {
              throw "Type " + xs[i] + " not found!";
            }
          }
        }
      }
      cons = new Constructor(name, this, vars);
      this.constructors[cons.name] = cons; // adding constructor to the list of constructors
      return this[cons.name] = cons.new; // adding "new" generating function as a constructor name - for cleaner syntax! (Nat.Z is a function call instead of Nat.Z.new)
    }

    //@[cons.name].bind cons # binding this to newly created constructor

    // helper function that returns name of the type *even if v is not Value* but a primitive type
    static checkType(v) {
      if (v instanceof Value) {
        return v._type_;
      } else {
        switch (typeof v) {
          case "string":
            return Type.String;
          case "number":
            return Type.Float;
          default:
            throw "We got an unboxed value of type " + (typeof v) + " -- shouldn't happen!";
        }
      }
    }

    shortShow(inside = false) {
      var j, len, ref, ret, v;
      ret = (this.vars.length > 0) && inside ? "(" + this.name : this.name;
      ref = this.vars;
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        ret = ret + " " + v.name;
      }
      ret = (this.vars.length > 0) && inside ? ret + ")" : ret;
      return ret;
    }

    show() {
      var cs, i, j, ref, ret;
      ret = "type " + this.shortShow();
      cs = Object.keys(this.constructors);
      if (cs.length > 0) {
        ret += " = " + this.constructors[cs[0]].show();
        for (i = j = 1, ref = cs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
          ret += " | " + this.constructors[cs[i]].show();
        }
      }
      return ret;
    }

    // returns array of all types pretty printed as Strings
    static showAllTypes() {
      var ret, t;
      ret = [];
      for (t in Type) {
        if (Type[t] instanceof Type) {
          ret.push(Type[t].show());
        }
      }
      return ret;
    }

  };

  // some built in types
  TOP = new Type("_TOP_"); // top type of all types - for the future subtyping?

  BOTTOM = new Type("_BOTTOM_"); // _|_ in Haskell

  EMPTY = new Type("_EMPTY_"); // () in Haskell

  UNIT = new Type("_UNIT_", "Unit"); // type with a single element

  // exposing constructors for cleaner syntax
  Unit = UNIT.Unit;

  //console.log Unit().show()

  // primitive types (substituted into js types directly)
  JInt = new Type("Int", "I#");

  JFloat = new Type("Float", "F#");

  JString = new Type("String", "S#");

  // some standard types - exposing constructors right away
  // THIS SHOULD GO TO Type creation function - just add the names to Exports!!!
  Pair = (new Type("Pair a b", "Pair a b")).Pair;

  //p = Pair 1, 2
  Left = (new Type("Either a b", "Left a", "Right b")).Left;

  Right = Type.Either.Right;

  Just = (new Type("Maybe a", "Just a", "Nothing")).Just;

  Nothing = Type.Maybe.Nothing;

  Cell = (new Type("List a", "Cell a List", "Nil")).Cell;

  Nil = Type.List.Nil;

  Z = (new Type("Nat", "Z", "S Nat")).Z;

  S = Type.Nat.S;

  T = Type; // alias for global types, so that we can write things like T.Int

  
  // our functional function with pattern matching and type checking and polymorphism
  Func = class Func {
    constructor(name1, arity) {
      this.match = this.match.bind(this);
      // function application - think through
      // now only works with 1 argument - think about lambda for many argument functions???
      this.ap = this.ap.bind(this);
      this.name = name1;
      this.arity = arity;
      this.functions = {};
    }

    match(consTag, func) {
      return this.functions[consTag] = func;
    }

    ap(...vals) {
      var fn, v, x;
      v = vals[0];
      if (!(v instanceof Value)) {
        throw "Type error while calling " + this.name;
      }
      for (x in this.functions) {
        if (x === v._constructorTag_) {
          // pattern matching first
          fn = x;
        }
      }
      return this.functions[fn](v); // calling matched function with the argument
    }

  };

  
  // Some tests #################################################

  //Maybe.add "Nothing"
  //Maybe.add "Just a"
  //tMaybe.add "Crazy Int"
  //tMaybe.add "MoreCrazy Afasf"
  tCustom = new Type("Custom", "Cons Float String");

  ref = Type.showAllTypes();
  for (j = 0, len = ref.length; j < len; j++) {
    t = ref[j];
    console.log(t);
  }

  length = new Func("length");

  length.match("Nil", function() {
    return 0;
  });

  length.match("Cell", function(x) {
    return 1 + length.ap(tail(x));
  });

  f1 = new Func("toInt", 1);

  f1.match("Z", function() {
    return 0;
  });

  f1.match("S", function(x) {
    return 1 + f1.ap(x['0']);
  });

  toInt = f1.ap;

  //console.dir toInt
  //console.dir Maybe, {depth: 4, colors: true}
  //console.dir List, {depth: 4, colors: true}
  //console.dir Type, {depth: 6, colors: true}
  two = S(S(S(S(Z()))));

  console.log(Z().show());

  console.log(two.show());

  y0 = toInt(Z());

  y1 = toInt(two);

  console.log(y0, y1);

  t1 = T.Custom.Cons(2, "Hello");

  console.log(t1.show());

  //console.log T.List.constructors.Cell.show()
//console.log T.List.show()

}).call(this);

//# sourceMappingURL=systemfj.js.map
