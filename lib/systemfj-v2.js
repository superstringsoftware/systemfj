// Generated by CoffeeScript 1.12.7
(function() {
  var Constructor, T, Type, runTests, show, util,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  util = require('util');

  util.inspect.defaultOptions.colors = true;

  Constructor = (function() {
    Constructor.MAGIC = -7777.777;

    function Constructor(type, index, name1, varBindings) {
      this.type = type;
      this.index = index;
      this.name = name1;
      this["new"] = bind(this["new"], this);
      this.varBindings = [];
      if (varBindings != null) {
        this.varBindings = varBindings;
      }
    }

    Constructor.prototype["new"] = function(v) {
      var i, j, ref, ret, vals;
      vals = [];
      if (v instanceof Array) {
        vals = v;
      } else {
        if (v != null) {
          vals = [v];
        }
      }
      if (vals.length !== this.varBindings.length) {
        throw "Expecting " + this.varBindings.length + " arguments and received " + vals.length + " in the call of " + this.name;
      }
      ret = [];
      for (i = j = 0, ref = vals.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (Type.isTypeOk(vals[i], this.varBindings[i])) {
          Object.freeze(vals[i]);
          ret.push(vals[i]);
        } else {
          throw "Type mismatch in the " + i + "-th argument in the call to " + this.name + ": expected " + this.varBindings[i].fullName() + " and got " + Type.getTypeName(vals[i]);
        }
      }
      ret.push(this.index);
      ret.push(Constructor.MAGIC);
      Object.freeze(ret);
      return ret;
    };

    return Constructor;

  })();

  Type = (function() {
    Type._typeVarNames = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];

    Type.allConstructors = [];

    Type.isTypeOk = function(val, binding) {
      var t1;
      if (typeof binding === "number") {
        return true;
      } else {
        t1 = Type.getTypeName(val);
        if (t1 === binding.fullName()) {
          return true;
        } else {
          return false;
        }
      }
    };

    Type.prototype.fullName = function() {
      var i, j, ref, ret;
      ret = this.name;
      for (i = j = 0, ref = this.varTypes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        ret += " " + Type._typeVarNames[i];
      }
      return ret;
    };

    Type.isTuple = function(v) {
      return (v instanceof Array) && (v[v.length - 1] === Constructor.MAGIC);
    };

    Type.getTypeName = function(v) {
      var cons, i, j, k, len, ref, ret, s, vararr, x;
      if (Type.isTuple(v)) {
        cons = Type.allConstructors[v[v.length - 2]];
        ret = cons.type.name;
        vararr = (function() {
          var j, ref, results;
          results = [];
          for (i = j = 0, ref = cons.type.varTypes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push(Type._typeVarNames[i]);
          }
          return results;
        })();
        for (i = j = 0, ref = cons.varBindings.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if (typeof cons.varBindings[i] === "number") {
            vararr[cons.varBindings[i]] = Type.getTypeName(v[i]);
          }
        }
        for (k = 0, len = vararr.length; k < len; k++) {
          x = vararr[k];
          ret += " " + x;
        }
        return ret;
      } else {
        switch (typeof v) {
          case "string":
            return "String";
          case "number":
            if (Number.isInteger(v)) {
              return "Int";
            } else {
              return "Float";
            }
            break;
          case "boolean":
            return "Bool";
          case "function":
            return "Function";
          case "object":
            s = v.constructor.toString();
            return s.substring((s.indexOf(' ')) + 1, s.indexOf('('));
          default:
            throw "We got an unboxed value of type " + (typeof v) + " while checking type -- shouldn't happen!";
        }
      }
    };

    function Type(name1, varTypes) {
      this.name = name1;
      this.cons = bind(this.cons, this);
      this.fullName = bind(this.fullName, this);
      this.constructors = {};
      this.varTypes = [];
      if (varTypes != null) {
        this.varTypes = varTypes;
      }
      Type[this.name] = this;
    }

    Type["new"] = function(name, varTypes) {
      var i, j, ref, vt;
      switch (typeof varTypes) {
        case "undefined":
          return new Type(name);
        case "number":
          vt = [];
          for (i = j = 0, ref = varTypes; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            vt.push(Type.Type);
          }
          return new Type(name, vt);
        default:
          if (varTypes instanceof Array) {
            return new Type(name, varTypes);
          } else {
            throw "Unexpected arguments in Type construction!";
          }
      }
    };

    Type.prototype.cons = function(name, bindings) {
      var c;
      c = new Constructor(this, Type.allConstructors.length, name, bindings);
      Type.allConstructors.push(c);
      this.constructors[name] = c;
      global[name] = c;
      return this;
    };

    return Type;

  })();

  show = function(v, top_level) {
    var cons, i, j, ref, ret;
    if (top_level == null) {
      top_level = true;
    }
    cons = Type.allConstructors[v[v.length - 2]];
    ret = (v.length > 2) && (!top_level) ? "(" + cons.name : cons.name;
    for (i = j = 0, ref = v.length - 2; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (Type.isTuple(v[i])) {
        ret += " " + show(v[i], false);
      } else {
        ret += typeof v[i] === "string" ? " '" + v[i] + "'" : " " + v[i];
      }
    }
    ret = (v.length > 2) && (!top_level) ? ret + ")" : ret;
    if (top_level) {
      ret += " :: " + Type.getTypeName(v);
    }
    return ret;
  };

  Type["new"]("Type");

  Type["new"]("Int");

  T = Type;

  runTests = function() {
    var l1, l2;
    Type["new"]("Maybe", 1).cons("Just", [0]).cons("Nothing");
    Type["new"]("Pair", 2).cons("Pair", [0, 1]);
    Type["new"]("Either", 2).cons("Left", [0]).cons("Right", [1]);
    Type["new"]("Strange", 1).cons("Crazy", [T.Int, 0]);
    Type["new"]("Concrete").cons("Concrete", [T.Int]);
    Type["new"]("List", 1).cons("Cell", [0, Type.List]).cons("Nil");
    console.log(show(Just["new"](17)));
    console.log(show(Just["new"]("hello")));
    console.log(show(Nothing["new"]()));
    console.log(show(Concrete["new"](41)));
    console.log(show(Pair["new"](["Hello", 249])));
    console.log(show(Right["new"]("hello")));
    console.log(show(Left["new"](3.1415)));
    console.log(show(Crazy["new"]([4, "hello"])));
    l1 = Cell["new"]([5, Nil["new"]()]);
    console.log(show(l1));
    return l2 = Cell["new"]([18.7, l1]);
  };

  runTests();

}).call(this);
