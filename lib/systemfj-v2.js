// Generated by CoffeeScript 1.12.7
(function() {
  var Constructor, T, Type, runTests, show, util,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  util = require('util');

  util.inspect.defaultOptions.colors = true;

  util.inspect.defaultOptions.depth = 3;

  Constructor = (function() {
    Constructor.MAGIC = -7777.777;

    function Constructor(type, index, name1, varBindings) {
      this.type = type;
      this.index = index;
      this.name = name1;
      this.updateCurrentBindings = bind(this.updateCurrentBindings, this);
      this["new"] = bind(this["new"], this);
      this.varBindings = [];
      if (varBindings != null) {
        this.varBindings = varBindings;
      }
      this.currentVarBindings = [];
    }

    Constructor.prototype["new"] = function(v) {
      var i, j, ref, ret, vals, vb;
      vals = [];
      if (v instanceof Array) {
        vals = v;
      } else {
        if (v != null) {
          vals = [v];
        }
      }
      if (vals.length !== this.varBindings.length) {
        throw "Expecting " + this.varBindings.length + " arguments and received " + vals.length + " in the call of " + this.name;
      }
      ret = [];
      this.currentVarBindings = this.varBindings.slice();
      for (i = j = 0, ref = vals.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        vb = this.currentVarBindings[i];
        if (Type.isTypeOk(vals[i], vb)) {
          if (typeof vb === "number") {
            this.updateCurrentBindings(i, Type.getType(vals[i]));
          }
          Object.freeze(vals[i]);
          ret.push(vals[i]);
        } else {
          throw "Type mismatch in the argument #" + (i + 1) + " in the call to " + this.name + ": expected " + vb.fullName() + " and got " + Type.getTypeName(vals[i]);
        }
      }
      ret.push(this.index);
      ret.push(Constructor.MAGIC);
      Object.freeze(ret);
      return ret;
    };

    Constructor.prototype.updateCurrentBindings = function(k, val) {
      var i, j, ref, results, t;
      results = [];
      for (i = j = 0, ref = this.currentVarBindings.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (this.currentVarBindings[i] === k) {
          this.currentVarBindings[i] = val;
        }
        if (this.type.name === this.currentVarBindings[i].name) {
          t = this.currentVarBindings[i]._clone();
          t.varTypes[k] = val;
          results.push(this.currentVarBindings[i] = t);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return Constructor;

  })();

  Type = (function() {
    Type._typeVarNames = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];

    Type.allConstructors = [];

    Type.isTypeOk = function(val, binding) {
      var i, j, ok, ref, ref1, ref2, ret, tt, vt;
      if (typeof binding === "number") {
        return true;
      } else {
        vt = (Type.getTypeName(val)).split(' ');
        tt = binding.fullName().split(' ');
        ret = true;
        for (i = j = 0, ref = tt.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if ((ref1 = tt[i], indexOf.call(Type._typeVarNames, ref1) >= 0) || (ref2 = vt[i], indexOf.call(Type._typeVarNames, ref2) >= 0)) {
            ok = true;
          } else {
            ok = vt[i] === tt[i] ? true : false;
          }
          ret = ret && ok;
        }
        return ret;
      }
    };

    Type.prototype.fullName = function() {
      var i, j, ref, ret;
      ret = this.name;
      for (i = j = 0, ref = this.varTypes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        ret += this.varTypes[i].name === "Type" ? " " + Type._typeVarNames[i] : " " + this.varTypes[i].name;
      }
      return ret;
    };

    Type.isTuple = function(v) {
      return (v instanceof Array) && (v[v.length - 1] === Constructor.MAGIC);
    };

    Type.getType = function(v) {
      var cons;
      if (Type.isTuple(v)) {
        cons = Type.allConstructors[v[v.length - 2]];
        return cons.type;
      } else {
        switch (typeof v) {
          case "string":
            return Type.String;
          case "number":
            if (Number.isInteger(v)) {
              return Type.Int;
            } else {
              return Type.Float;
            }
            break;
          case "boolean":
            return Type.Bool;
          case "function":
            return Type.Function;
          case "object":
            return Type.Object;
          default:
            throw "We got an unboxed value of type " + (typeof v) + " while checking type -- shouldn't happen!";
        }
      }
    };

    Type.getTypeName = function(v) {
      var cons, i, j, l, len, ref, ret, s, vararr, x;
      if (Type.isTuple(v)) {
        cons = Type.allConstructors[v[v.length - 2]];
        ret = cons.type.name;
        vararr = (function() {
          var j, ref, results;
          results = [];
          for (i = j = 0, ref = cons.type.varTypes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            results.push(Type._typeVarNames[i]);
          }
          return results;
        })();
        for (i = j = 0, ref = cons.varBindings.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          if (typeof cons.varBindings[i] === "number") {
            vararr[cons.varBindings[i]] = Type.getTypeName(v[i]);
          }
        }
        for (l = 0, len = vararr.length; l < len; l++) {
          x = vararr[l];
          ret += " " + x;
        }
        return ret;
      } else {
        switch (typeof v) {
          case "string":
            return "String";
          case "number":
            if (Number.isInteger(v)) {
              return "Int";
            } else {
              return "Float";
            }
            break;
          case "boolean":
            return "Bool";
          case "function":
            return "Function";
          case "object":
            s = v.constructor.toString();
            return s.substring((s.indexOf(' ')) + 1, s.indexOf('('));
          default:
            throw "We got an unboxed value of type " + (typeof v) + " while checking type -- shouldn't happen!";
        }
      }
    };

    function Type(name1, varTypes, addToTypes) {
      this.name = name1;
      if (addToTypes == null) {
        addToTypes = true;
      }
      this.cons = bind(this.cons, this);
      this.instantiate = bind(this.instantiate, this);
      this._clone = bind(this._clone, this);
      this.fullName = bind(this.fullName, this);
      this.constructors = {};
      this.varTypes = [];
      if (varTypes != null) {
        this.varTypes = varTypes;
      }
      if (addToTypes) {
        Type[this.name] = this;
      }
    }

    Type.prototype._clone = function() {
      return new Type(this.name, this.varTypes.slice(), false);
    };

    Type.prototype.instantiate = function(vals) {
      if (vals.length !== this.varTypes.length) {
        throw "Have to instantiate a type with full signature now!";
      }
      return new Type(this.name, vals, false);
    };

    Type["new"] = function(name, varTypes) {
      var i, j, ref, vt;
      switch (typeof varTypes) {
        case "undefined":
          return new Type(name);
        case "number":
          vt = [];
          for (i = j = 0, ref = varTypes; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            vt.push(Type.Type);
          }
          return new Type(name, vt);
        default:
          if (varTypes instanceof Array) {
            return new Type(name, varTypes);
          } else {
            throw "Unexpected arguments in Type construction!";
          }
      }
    };

    Type.prototype.cons = function(name, bindings) {
      var c;
      c = new Constructor(this, Type.allConstructors.length, name, bindings);
      Type.allConstructors.push(c);
      this.constructors[name] = c;
      global[name] = c;
      return this;
    };

    return Type;

  })();

  show = function(v, top_level) {
    var cons, i, j, ref, ret;
    if (top_level == null) {
      top_level = true;
    }
    cons = Type.allConstructors[v[v.length - 2]];
    ret = (v.length > 2) && (!top_level) ? "(" + cons.name : cons.name;
    for (i = j = 0, ref = v.length - 2; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (Type.isTuple(v[i])) {
        ret += " " + show(v[i], false);
      } else {
        ret += typeof v[i] === "string" ? " '" + v[i] + "'" : " " + v[i];
      }
    }
    ret = (v.length > 2) && (!top_level) ? ret + ")" : ret;
    if (top_level) {
      ret += " :: " + Type.getTypeName(v);
    }
    return ret;
  };

  Type["new"]("Type");

  Type["new"]("Int");

  Type["new"]("Float");

  Type["new"]("String");

  Type["new"]("Function");

  Type["new"]("Object");

  T = Type;

  runTests = function() {
    var l1, l2;
    Type["new"]("Maybe", 1).cons("Just", [0]).cons("Nothing");
    Type["new"]("Pair", 2).cons("Pair", [0, 1]);
    Type["new"]("Either", 2).cons("Left", [0]).cons("Right", [1]);
    Type["new"]("Strange", 1).cons("Crazy", [T.Int, 0]);
    Type["new"]("Concrete").cons("Concrete", [T.Int]);
    Type["new"]("List", 1).cons("Cell", [0, Type.List]).cons("Nil");
    console.log(show(Just["new"](17)));
    console.log(show(Just["new"]("hello")));
    console.log(show(Nothing["new"]()));
    console.log(show(Concrete["new"](41)));
    console.log(show(Pair["new"](["Hello", 249])));
    console.log(show(Right["new"]("hello")));
    console.log(show(Left["new"](3.1415)));
    console.log(show(Crazy["new"]([4, "hello"])));
    l1 = Cell["new"]([5, Nil["new"]()]);
    console.log(show(l1));
    console.log("Now attaching Float to List Int - MUST FAIL!!!");
    console.log("==============================================");
    l2 = Cell["new"]([18.7, l1]);
    return console.log(show(l2));

    /*
    #l3 = Cell.new [15, 29] # has to fail 
    
    
     * for testing incremental construction
    Type.new "T1", 1
      .cons "T1C", [0, 0]
    
    t = T1C.new ["4", "7"]
    console.log show t
     */
  };

  runTests();

}).call(this);
