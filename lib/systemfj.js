// Generated by CoffeeScript 1.12.7
var T, f10, fromArray, head, id, imagPart, isZero, length, magnitude, map, realPart, runTests, show, tail, testF, toInt,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

require("babel-register");

export var Variable = (function() {
  function Variable(name1, boundTo) {
    this.name = name1;
    this.boundTo = boundTo;
  }

  Variable.prototype.bind = function(val) {
    throw "Variable::bind() shouldn't be called directly!";
  };

  Variable.prototype.show = function() {
    return console.dir(this);
  };

  return Variable;

})();

export var TypeVar = (function(superClass) {
  extend(TypeVar, superClass);

  function TypeVar(name, boundTo) {
    this.clone = bind(this.clone, this);
    this.shortShow = bind(this.shortShow, this);
    this.show = bind(this.show, this);
    TypeVar.__super__.constructor.call(this, name, boundTo);
  }

  TypeVar.prototype.kind = function() {};

  TypeVar.prototype.bind = function(val) {
    throw "TypeVar::bind() not implemented yet";
  };

  TypeVar.prototype.show = function() {
    return this.name + " :: " + "Type";
  };

  TypeVar.prototype.shortShow = function() {
    return this.name;
  };

  TypeVar.prototype.clone = function() {
    return new TypeVar(this.name, this.boundTo);
  };

  return TypeVar;

})(Variable);

export var Var = (function(superClass) {
  extend(Var, superClass);

  function Var(name, boundTo, type) {
    this.clone = bind(this.clone, this);
    this.show = bind(this.show, this);
    Var.__super__.constructor.call(this, name, boundTo);
    this.type = type;
  }

  Var.prototype.type = function() {
    return this.type;
  };

  Var.prototype.bind = function(val) {
    throw "Var::bind() not implemented yet";
  };

  Var.prototype.show = function() {
    return this.name + " :: " + this.type.name;
  };

  Var.prototype.clone = function() {
    var v;
    v = new Var(this.name, this.boundTo);
    v.type = (this.type instanceof TypeVar) ? this.type.clone() : this.type;
    return v;
  };

  return Var;

})(Variable);

export var Value = (function() {
  function Value(_constructorTag_1, _type_) {
    this._constructorTag_ = _constructorTag_1;
    this._type_ = _type_;
    this.show = bind(this.show, this);
  }

  Value.prototype.show = function(top_level) {
    var j, keys, len, ret, v;
    if (top_level == null) {
      top_level = true;
    }
    keys = (function() {
      var j, len, ref, results;
      ref = Object.keys(this);
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        if (v !== "show" && v !== "_constructorTag_" && v !== "_type_") {
          results.push(v);
        }
      }
      return results;
    }).call(this);
    ret = (keys.length > 0) && (!top_level) ? "(" + this._constructorTag_ : this._constructorTag_;
    for (j = 0, len = keys.length; j < len; j++) {
      v = keys[j];
      if (this[v] instanceof Value) {
        ret = ret + " " + (this[v].show(false));
      } else {
        ret += (typeof this[v] === "string") ? " '" + this[v] + "'" : " " + this[v].toString();
      }
    }
    ret = (keys.length > 0) && (!top_level) ? ret + ")" : ret;
    if (top_level) {
      ret = ret + " :: " + this._type_.name;
    }
    return ret;
  };

  return Value;

})();

export var Constructor = (function() {
  function Constructor(name1, type1, vars) {
    this.name = name1;
    this.type = type1;
    this.show = bind(this.show, this);
    this.newValue = bind(this.newValue, this);
    this["new"] = bind(this["new"], this);
    this.vars = [];
    if (vars != null) {
      this.vars = vars;
    }
  }

  Constructor.prototype._instantiate = function(n, val) {};

  Constructor.prototype._instantiateType = function(n, type) {};


  /* for typechecking polymorphic constructors, need to have a very different logic
  ideally, to follow lambda calculus, even if loosely, we need to do:
  - check types of the vals that the constructor is applied to
  - make sure it is possible to do that with all the constrains etc
  - instantiate type variables to concrete types in the Type, which should automatically generate Concrete Constructors
  - only now, CALL concrete constructor function with given values to generate Value
  
  Let's develop this on Just a constructor.
  Also, need to think how to kill typing in the "compiled code" - in a sense, we are doing 1 pass with dynamic typechecking,
  then if no errors - erase all typing info and keep just code.
  
  Idea: have different concrete Types as a sub-dictionary on the Type-generating function, so that we don't generate too many types,
  but once a programmer adds a specific type - we put it in the dictionary. So we'll have in Maybe a:
  Maybe Int, Maybe Float, Maybe String etc - but only if the values of this specific types are used.
  
  Alternative approach: maybe more lightweight, use generic constructor function, but use some sort of specific type annotations.
   */

  Constructor.prototype["new"] = function() {
    var i, j, ref, t, v, val, vals;
    vals = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    val = [];
    for (i = j = 0, ref = this.vars.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      v = vals[i];
      if (v != null) {
        t = this.vars[i].type;
        if (t instanceof TypeVar) {
          Object.freeze(v);
          val.push(v);
        } else {
          if (t.equals(Type.checkType(v))) {
            Object.freeze(v);
            val.push(v);
          } else {
            throw "Type mismatch in assignment!";
          }
        }
      }
    }
    val.push(this.name);
    val.push(this.type);
    Object.freeze(val);
    return val;
  };

  Constructor.prototype.newValue = function() {
    var i, j, ref, t, v, val, vals;
    vals = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    val = new Value(this.name, this.type);
    if (this.vars.length > 0) {
      for (i = j = 0, ref = this.vars.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        v = vals[i];
        if (v != null) {
          t = this.vars[i].type;
          if (t instanceof TypeVar) {
            console.log("new Value creation - Partially implemented");
            val[this.vars[i].name] = v;
          } else {
            if (t.equals(Type.checkType(v))) {
              val[this.vars[i].name] = v;
            } else {
              throw "Type mismatch in assignment!";
            }
          }
        }
      }
      return val;
    }
  };

  Constructor.prototype.show = function() {
    var j, len, ref, ret, v;
    ret = this.name;
    ref = this.vars;
    for (j = 0, len = ref.length; j < len; j++) {
      v = ref[j];
      ret = ret + " " + v.type.shortShow(true);
    }
    return ret;
  };

  return Constructor;

})();

export var Type = (function() {
  function Type(type, constructors) {
    this.show = bind(this.show, this);
    this.shortShow = bind(this.shortShow, this);
    this.add = bind(this.add, this);
    this.equals = bind(this.equals, this);
    var cons, i, j, len, xs;
    this.constructors = {};
    xs = type.split(' ');
    this.name = xs[0];
    this.vars = (function() {
      var j, ref, results;
      results = [];
      for (i = j = 1, ref = xs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        results.push(new TypeVar(xs[i], -1));
      }
      return results;
    })();
    for (j = 0, len = constructors.length; j < len; j++) {
      cons = constructors[j];
      this.add(cons);
    }
    Type[this.name] = this;
  }

  Type["new"] = function() {
    var args, type;
    type = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return new Type(type, args);
  };

  Type.prototype.equals = function(type) {
    if (type instanceof Type) {
      return this.name === type.name;
    } else {
      return this.name === type;
    }
  };

  Type.prototype.add = function(cons) {
    var i, j, name, ref, t, v, vars, xs;
    xs = cons.split(' ');
    name = xs[0];
    vars = [];
    for (i = j = 1, ref = xs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
      v = this.vars.findIndex((function(_this) {
        return function(el) {
          return el.name === xs[i];
        };
      })(this));
      if (v !== -1) {
        vars.push(new Var((i - 1).toString(), -1, new TypeVar(xs[i], v)));
      } else {
        if (xs[i] === this.name) {
          vars.push(new Var((i - 1).toString(), -1, this));
        } else {
          t = Type[xs[i]];
          if (t != null) {
            vars.push(new Var((i - 1).toString(), -1, t));
          } else {
            throw "Type " + xs[i] + " not found!";
          }
        }
      }
    }
    cons = new Constructor(name, this, vars);
    this.constructors[cons.name] = cons;
    this[cons.name] = cons["new"];
    return global[cons.name] = cons["new"];
  };

  Type.isTuple = function(v) {
    return (v instanceof Array) && (v[v.length - 1] instanceof Type);
  };

  Type.checkType = function(v) {
    var ret, s;
    if (v instanceof Value) {
      v._type_;
    }
    if (Type.isTuple(v)) {
      return v[v.length - 1];
    } else {
      switch (typeof v) {
        case "string":
          return Type.String;
        case "number":
          return Type.Float;
        case "boolean":
          return Type.Bool;
        case "function":
          return Type.FUNCTION;
        case "object":
          s = v.constructor.toString();
          return ret = s.substring((s.indexOf(' ')) + 1, s.indexOf('('));
        default:
          throw "We got an unboxed value of type " + (typeof v) + " while checking type -- shouldn't happen!";
      }
    }
  };

  Type.checkConstructor = function(v) {
    var s;
    if (v instanceof Value) {
      v._constructorTag_;
    }
    if (Type.isTuple(v)) {
      return v[v.length - 2];
    } else {
      switch (typeof v) {
        case "string":
          return "String";
        case "number":
          return "Float";
        case "boolean":
          return "Bool";
        case "function":
          return "Function";
        case "object":
          s = v.constructor.toString();
          return s.substring((s.indexOf(' ')) + 1, s.indexOf('('));
        default:
          throw "We got an unboxed value of type " + (typeof v) + " while checking Constructor -- shouldn't happen!";
      }
    }
  };

  Type.prototype.shortShow = function(inside) {
    var j, len, ref, ret, v;
    if (inside == null) {
      inside = false;
    }
    ret = (this.vars.length > 0) && inside ? "(" + this.name : this.name;
    ref = this.vars;
    for (j = 0, len = ref.length; j < len; j++) {
      v = ref[j];
      ret = ret + " " + v.name;
    }
    ret = (this.vars.length > 0) && inside ? ret + ")" : ret;
    return ret;
  };

  Type.prototype.show = function() {
    var cs, i, j, ref, ret;
    ret = "type " + this.shortShow();
    cs = Object.keys(this.constructors);
    if (cs.length > 0) {
      ret += " = " + this.constructors[cs[0]].show();
      for (i = j = 1, ref = cs.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        ret += " | " + this.constructors[cs[i]].show();
      }
    }
    return ret;
  };

  Type.showAllTypes = function() {
    var ret, t;
    ret = [];
    for (t in Type) {
      if (Type[t] instanceof Type) {
        ret.push(Type[t].show());
      }
    }
    return ret;
  };

  return Type;

})();


/*
HELPER FUNCTIONS --------------------------------------------------------------
 */

show = (function(_this) {
  return function(val, top_level) {
    var _constructorTag_, i, j, ref, ret;
    if (top_level == null) {
      top_level = true;
    }
    _constructorTag_ = val[val.length - 2];
    ret = (val.length > 2) && (!top_level) ? "(" + _constructorTag_ : _constructorTag_;
    for (i = j = 0, ref = val.length - 2; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (Type.isTuple(val[i])) {
        ret = ret + " " + show(val[i], false);
      } else {
        ret += (typeof val[i] === "string") ? " '" + val[i] + "'" : " " + val[i].toString();
      }
    }
    ret = (val.length > 2) && (!top_level) ? ret + ")" : ret;
    if (top_level) {
      ret = ret + " :: " + val[val.length - 1].name;
    }
    return ret;
  };
})(this);


/*
 * some built in types --------------------------------------------------------------
 */

Type["new"]("_TOP_");

Type["new"]("_BOTTOM_");

Type["new"]("_EMPTY_");

Type["new"]("_UNIT_", "Unit");

Type["new"]("FUNCTION");

Type["new"]("Int", "I#");

Type["new"]("Float", "F#");

Type["new"]("String", "S#");

Type["new"]("Bool", "B#");

Type["new"]("Array", "A#");

T = Type;

Type["new"]("Pair a b", "Pair a b");

Type["new"]("Either a b", "Left a", "Right b");

Type["new"]("Maybe a", "Just a", "Nothing");

Type["new"]("Nat", "Z", "S Nat");


/*
FUNCTION CLASS with pattern matching and partial application  --------------------------------------------------------------
 */

export var Func = (function() {
  function Func() {
    var i, j, name1, ref, varTypes;
    name1 = arguments[0], varTypes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    this.name = name1;
    this.show = bind(this.show, this);
    this.ap = bind(this.ap, this);
    this.match = bind(this.match, this);
    this.matchMany = bind(this.matchMany, this);
    this.matchOne = bind(this.matchOne, this);
    this["default"] = bind(this["default"], this);
    this._clone = bind(this._clone, this);
    this.functions = {};
    this.vars = [];
    this.vals = [];
    this.returnType = varTypes.pop();
    for (i = j = 0, ref = varTypes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      this.vars.push(new Var(i.toString(), -1, varTypes[i]));
    }
    this.functions["__DEFAULT__"] = (function(_this) {
      return function() {
        var a, e, k, len, len1, o, p, ref1, v;
        console.dir(arguments);
        v = "Arguments:";
        for (o = 0, len = arguments.length; o < len; o++) {
          a = arguments[o];
          v += " " + Type.checkConstructor(a);
        }
        e = "Expected: ";
        ref1 = _this.vars;
        for (p = 0, len1 = ref1.length; p < len1; p++) {
          k = ref1[p];
          e += " " + k.type.name;
        }
        throw "Non-exaustive pattern match in definition of " + _this.show() + "\n" + v + "\n" + e;
      };
    })(this);
    this.fdef = this.functions["__DEFAULT__"];
  }

  Func.prototype._clone = function() {
    var f, v;
    f = new Func(this.name);
    f.returnType = this.returnType;
    f.fdef = this.fdef;
    f.functions = this.functions;
    f.vars = (function() {
      var j, len, ref, results;
      ref = this.vars;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        v = ref[j];
        results.push(v.clone());
      }
      return results;
    }).call(this);
    f.vals = this.vals.slice(0);
    return f;
  };

  Func.prototype["default"] = function(func) {
    this.functions["__DEFAULT__"] = func;
    return this.fdef = func;
  };

  Func.prototype.matchOne = function(consTag, func) {
    return this.functions[consTag] = func;
  };

  Func.prototype.matchMany = function(patterns, func) {
    var j, len, pat, v;
    pat = "";
    for (j = 0, len = patterns.length; j < len; j++) {
      v = patterns[j];
      pat += v;
    }
    return this.functions[pat] = func;
  };

  Func.prototype.match = function(patterns, func) {
    switch (typeof patterns) {
      case "function":
        this["default"](patterns);
        break;
      case "string":
        this.matchOne(patterns, func);
        break;
      default:
        if (patterns instanceof Array) {
          this.matchMany(patterns, func);
        } else {
          throw "Unrecognized pattern in pattern match definition of" + this.show();
        }
    }
    return this;
  };

  Func.prototype.ap = function() {
    var allVals, f, j, len, len1, o, pat, v, vals;
    vals = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (vals.length < this.vars.length) {
      f = this._clone();
      for (j = 0, len = vals.length; j < len; j++) {
        v = vals[j];
        f.vals.push(v);
      }
      f.vars = f.vars.slice(vals.length);
      return f.ap;
    } else {
      allVals = this.vals.concat(vals);
      pat = "";
      for (o = 0, len1 = allVals.length; o < len1; o++) {
        v = allVals[o];
        pat += Type.checkConstructor(v);
      }
      f = this.functions[pat];
      if (f != null) {
        return f.apply(this, allVals);
      } else {
        return this.fdef.apply(this, allVals);
      }
    }
  };

  Func.prototype.show = function() {
    var i, j, ref, ret;
    ret = this.name + " :: ";
    for (i = j = 0, ref = this.vars.length - 1; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      ret += this.vars[i].type.name + " -> ";
    }
    ret += this.vars[this.vars.length - 1].type.name;
    return ret += " -> " + this.returnType.name;
  };

  return Func;

})();

export var _ = "__ANY_PATTERN_MATCH__";


/*
TYPE CLASSES --------------------------------------------------------------

e.g.: - signature definition
class Show a where
  show :: a -> String

adding implementation to the dictionary indexed by 'a':
instance Show MyType where
  show (MyTypeCons x) = toString x

then, when show is called on a value of some type we check the type, find
the corresponding function in the dictionary and call it
 */

export var TypeClass = (function() {
  function TypeClass() {
    var i, j, name1, ref, varTypes;
    name1 = arguments[0], varTypes = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    this.name = name1;
    this.functions = {};
    this.vars = [];
    this.returnType = varTypes.pop();
    for (i = j = 0, ref = varTypes.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      this.vars.push(new Var(i.toString(), -1, varTypes[i]));
    }
  }

  return TypeClass;

})();


/*
 * ========= LISTS VIA TYPECLASSES =========================================================
 */

Type["new"]("List a", "Cell a List", "Nil");

Type["new"]("JList a", "JList Array");

fromArray = new Func("fromArray", Type.Array, Type.JList).match("Array", function(a) {
  return JList(a);
}).ap;

head = new Func("head").match("JList", function(arg) {
  var l;
  l = arg[0];
  return l[0];
}).ap;

tail = new Func("tail", Type.JList, Type.JList).match("JList", function(arg) {
  var l;
  l = arg[0];
  return JList(l.slice(1));
}).ap;


/*
SOME STANDARD FUNCTIONS --------------------------------------------------------------
 */

id = new Func("id").match(function(x) {
  return x;
}).ap;

isZero = new Func("isZero", Type.Nat, Type.Bool).match("Z", function() {
  return true;
}).match("S", function() {
  return false;
}).ap;

toInt = new Func("toInt", Type.Nat, Type.Int).match("Z", function() {
  return 0;
}).match("S", function(arg) {
  var x;
  x = arg[0];
  return 1 + toInt(x);
}).ap;

Type["new"]("Complex", "Complex Float Float");

realPart = new Func("realPart", Type.Complex, Type.Float).match("Complex", function(arg) {
  var x;
  x = arg[0];
  return x;
}).ap;

imagPart = new Func("realPart", Type.Complex, Type.Float).match("Complex", function(arg) {
  var _, y;
  _ = arg[0], y = arg[1];
  return y;
}).ap;

magnitude = new Func("magnitude", Type.Complex, Type.Float).match("Complex", function(arg) {
  var x, y;
  x = arg[0], y = arg[1];
  return x * x + y * y;
}).ap;

length = new Func("length", Type.List, Type.Int).match("Nil", function() {
  return 0;
}).match("Cell", function(arg) {
  var _, tail;
  _ = arg[0], tail = arg[1];
  return 1 + length(tail);
}).ap;

map = new Func("map", Type.FUNCTION, Type.List, Type.List).match(["Function", "Nil"], function() {
  return Nil();
}).match(["Function", "Cell"], function(f, arg) {
  var tail, x;
  x = arg[0], tail = arg[1];
  return Cell(f(x), map(f, tail));
}).ap;

testF = new Func("testF", Type.Float, Type.Float, Type.Float, Type.Float).match(["Float", "Float", "Float"], function(x, y, z) {
  return x * y + z;
}).ap;

f10 = function() {
  console.dir(arguments[0].toString());
  return console.dir(Type.checkConstructor(arguments[0]));
};

runTests = function() {
  var c1, j1, j2, j3, l, m, testF4, testF47, testL, two, x1, x2, xxxxx, y0, y1;
  two = S(S(S(S(Z()))));
  console.log(show(Z()));
  console.log(show(two));
  y0 = toInt(Z());
  y1 = toInt(two);
  console.log(y0, y1);
  console.log("isZero Z, isZero two");
  console.log(isZero(Z()));
  console.log(isZero(two));
  j1 = Just(2);
  j2 = Just("Hello");
  j3 = Just(two);
  console.log(show(j1));
  console.log(show(j2));
  console.log(show(j3));
  c1 = Complex(2.3, -1.4);
  console.log(show(c1));
  console.log(magnitude(c1));
  console.log("Real: " + realPart(c1));
  console.log("Imag: " + imagPart(c1));
  console.log(id(4));
  console.log(id("hello"));
  console.log(show(id(two)));
  l = Cell(1, Cell(2, Cell(3, Nil())));
  console.log(show(l));
  console.log("Length of l: " + length(l));
  console.log("Testing map");
  m = map((function(x) {
    return x * 2;
  }), l);
  console.log(show(m));
  console.log("Testing partial application");
  console.log(testF(4, 7, 2));
  testF4 = testF(4);
  testF47 = testF4(7);
  console.log(testF4(7, 2));
  console.log(testF47(2));
  console.log(testF(1, 2, 0));
  console.log("Testing constructors");
  console.log(Type.checkConstructor(two));
  x1 = new Var;
  x2 = new Type("Hello", "Hello");
  console.log(Type.checkConstructor(x1));
  console.log(Type.checkConstructor(x2));
  console.log("Testing built in lists");
  testL = fromArray([1, 3, 4, 10, 12]);
  console.dir(testL);
  console.log("Head and tail");
  console.log(head(testL));
  console.log(tail(testL));
  xxxxx = fromArray({
    head: 2
  }, new Var);
  return console.log(xxxxx);
};

runTests();
